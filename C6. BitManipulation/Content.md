###Content - Bit Manipulation

# 第一章：位运算在计算机领域和面试领域的意义

使用位运算，主要目的是<u>节约内存</u>，<u>使你的程序速度更快</u>，还有就是<u>对内存要求苛刻</u>的地方使用。



# 第二章：基本运算的讲解

1. 左移操作 `A << B`
2. 右移操作 `A >> B, A >>> B`
3. 按位与操作 `A & B`
4. 按位或操作 `A | B`
5. 按位非操作 `~A`
6. 异或操作 `A ^ B`



# 左移操作 A << B

将 A 的二进制表示的整体向左移 B 位，左边超出 32 位的截掉（如果是 int 的话），右边不足的位补 0
比如对于10进制数12，他的二进制表示下，是`1100`，那么将其左移 2 位，得到的结果是 `110000`。

在程序实现的时候，写法如下：

```
int A = 12;
int B = 2;

// C 的值将是 (110000)2 也就是十进制中的 48
int C = A << B;

```

可以看出，左移操作的结果“几乎”等于`A * 2^B`（如果不溢出的情况下）。

#### 那为什么不直接写成 A * 2^B 呢？

因为位移运算比乘法和求幂的运算快很多很多



# 右移操作 A >> B , A >>> B

**右移操作分为逻辑右移和算术右移**

1. 算术右移是带符号的右移 A >> B
2. 逻辑右移是不带符号的右移 A >>> B

`算术右移`：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补符号位的数（比如负数符号位是1则补充1，正数符号位是0则补充0），所以**对于算术右移，原来是负数的，结果还是负数，原来是正数的结果还是正数**。

`逻辑右移`：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补0。所以对于逻辑右移，结果将会是一个**正数**

举个例子对于十进制数`-127`, 已知(-127)10 = (11111111111111111111111110000001)2 /* **因为是负数，所以最高位上是1** */
算术右移的运算过程是：

A = (-127)10 >> 2 = (11111111111111111111111110000001)2 >> 2 = (11111111111111111111111111100000)2 = (-32)10

Java语言code如下：

```
int a = -127 >> 2; // a的值将是-32

```

逻辑右移的运算过程是：

A = (-127)10 >> 2 = (11111111111111111111111110000001)2 >> 2 = (00111111111111111111111111100000)2 = `(1073741792)10`

Java语言code如下：

```
int a = -127 >>> 2; // a的值将是1073741792

```

### 所有语言都一样么？

不是的，只有Java里面有特殊的`>>>`符号，对于C++或者C的一些语言标准中指出，`无符号数`执行的所有移位操作都是逻辑的，而对于`有符号数`，采用哪种方式`取决于编译器`。算术左移和逻辑左移是相同的，而`算术右移和逻辑右移，取决于符号位`。这个也就题外话，你能记住当然最好，不能记住也没有关系。



# 按位与操作 a & b

将A和B的二进制表示的每一位进行与操作，只有两个对应的二进制位**都为1时**，结果位才为1，否则为0.

```
1 & 1 = 1
1 & 0 = 0
0 & 1 = 0
0 & 0 = 0

```

具体如：
A = `(10)10` = `(001010)2`
B = `(44)10` = `(101100)2`

A & B = 10 & 44 = 001010 & 101100 = (001000)2 = (8)10

##### 你可能会问为什么这里10对应的二进制是001010，而不是1010？

- 这是因为我们对于空缺的位置使用`0`去补足即可。

所以10和44进行`&`运算的结果是`8`

具体使用Java程序实现如下：

```
int a = 10 & 44; // a的值是8
```





# 按位或操作 a | b

将A和B的二进制表示的每一位进行`或`操作，只要两个对应的二进制位有一个为`1`，结果位就为`1`，否则为`0`.

```
1 | 1 = 1
1 | 0 = 1
0 | 1 = 1
0 | 0 = 0

```

具体如：
A = `(10)10` = `(001010)2`
B = `(44)10` = `(101100)2`

A | B = 10 | 44 = 001010 | 101100 = (101110)2 = (46)10

所以10和44进行`|`运算的结果是`46`

具体使用Java程序实现如下：

```
int a = 10 | 44; // a的值是46
```



# 按位非操作 ~ a

将A的二进制表示`每一位`进行`取反`操作，如果对应的二进制位为0，结果位为1，否则为0.

**注意** 这里是指一个位`(bit)`取反，对`整数1`取反结果`不是0`，因为`整数1`由`32位(bit)`组成。
比如十进制1， 表示成2进制是(00000000000000000000000000000001)2, 这里是32位有符号整数。

```
 A =   (1)10 = (00000000000000000000000000000001)2
~A = ~ (1)10 = (11111111111111111111111111111110)2 = (-2)10

```

所以对整数1进行取非操作，得到的结果是-2。
Java中的实现如下：

```
int a = ~1;
System.out.println(a); // 此时输出的值为-2.

```

#### 再举一个例子：

```
 A =   (10)10 = (00000000000000000000000000001010)2
~A = ~ (10)10 = (11111111111111111111111111110101)2 = (-11)2

```

### 值得注意的是，取反对`符号位`也是同样的操作。



# 按位异或操作 a ^ b

将A和B的二进制表示的每一位进行异或操作，如果对应的二进制位不同，结果位为1，否则为0.

```
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0

```

从上面这些结果中可以总结出，异或操作也就是`不进位加法`，比如1 + 1 = 10， 我们只取个位，不要进位的那个1，其他同理。

比如 A = `(10)10` = `(001010)2`, B = `(44)10` = `(101100)2`

```
A ^ B = (10)10 ^ (44)10 = (001010)2 ^ (101100)2 = (100110)2 = (38)10

具体的竖式操作：

A    001010
B    101100
-----------
C    100110

结果 C = (100110)2 = (38)10

```

Java的code为：

```
int a = 10 ^ 44; // a的值为38
```